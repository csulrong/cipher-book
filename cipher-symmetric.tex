
\startcomponent cipher-symmetric

\environment cipher-environment

\startchapter[title={对称加密算法},reference=ch:symmetric]

古典加密算法那些针对字符进行转换的加密方式在计算机技术所主导的信息时代已经没什么实用价值了。计算机的操作对象并非
针对文字，而是由0和1组成的比特序列。无论是文字、图像、声音、视频还是程序，在计算机中都是用比特序列来表示的。将
这些现实世界中的东西转换成比特序列的操作被称为{\it 编码} (encoding)。现代加密技术是以编码后的比特序列为基本
加密单元的。现代加密算法大致分为两大类：{\it 对称加密算法}和{\it 非对称加密算法}，如\in{图}[fig:modern]所示。

\startplacefigure[title={现代加密算法}, reference=fig:modern]
\midaligned{
\starttikzpicture
[edge from parent fork down, level distance=15mm,
level 1/.style={sibling distance=60mm},
level 2/.style={sibling distance=50mm},
level 3/.style={sibling distance=15mm},
every node/.style={fill=white!62.5!black,draw=red!62.5!black,thick,rounded corners,font=\Tiny},
edge from parent/.style={red!62.5!black,-o,thick,draw}]
\node {现代密码算法}
child {node {对称加密算法}
  child {node {分组密码}
    child {node {DES算法}}
    child {node {3DES算法}}
    child {node {AES算法}}
    child {node {Blowfish算法}}
  }
  child {node {流密码}
    child {node {RC4算法}}
    child {node {SEAL算法}}
  }
}
child {node {非对称加密算法}
  child[sibling distance=17mm] {node {RSA算法}}
  child[sibling distance=17mm] {node {EIGamal算法}}
  child[sibling distance=17mm] {node {ECC算法}}
};
\stoptikzpicture
}
\stopplacefigure

其中，对称加密算法还分为流密码和分组密码。本章将具体介绍几种常用的对称加密算法，包括流密码RC4和
分组密码DES、3DES、AES以及Blowfish。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startsection[title={流密码和分组密码},reference=sec:stream-vs-block]
\index{sec:stream-vs-block}

在对称加密算法中，按照加密方式的不同，可以分为流密码和分组密码。

在流密码加密方式下，明文称为明文流，以比特序列的方式表示。加密时候，先由种子密钥生成一个密钥流。然后利用加密算法
把明文流和密钥流进行加密，产生密文流。流密码一般以1比特、8比特、或32比特为单位进行加密和解密。加密过程所需要的
密钥流由种子密钥通过密钥流生成器产生。流密码的主要原理是通过随机数发生器产生性能优良的伪随机序列，使用该序列加密
明文流得到密文流。若密钥流是无周期、无限长随机序列，则每一个明文都对应一个随机的加密密钥，理论上，流密码是
“一次一密”密码体制,也就是绝对安全的。实际应用中密钥流都用有限存储和复杂逻辑的电路产生，此时它的生成器只有有限个
状态，这样，它早晚要回到初始状态而呈现出一定长度的周期，其输出也就是周期序列。所以,实际应用中的流密码不会实现
“一次一密”密码体制，但若生成的密钥流周期够长，随机性好，其安全强度还是能保证的。因此,密钥流生成器的设计是流密码
的核心，流密码的安全强度取决于密钥流的周期、复杂度、随机（伪随机）性等。流密码涉及许多理论知识，提了很多设计原理，
得到了广泛分析，但很多研究成果并没有全部公开，可能是因为目前流密码主要用于军事和外交。日前,公开的流密码算法主要
有RC4、SEAL等。

分组密码又称块密码。当加密明文时，先把明文变成二进制比特序列，然后将其划分成若干个固定长度的组，不足位用0补全。
分组长度通常是64比特、128比特等。分组密码对每个分组逐个依次进行加密操作。分组长短影响密码强度，分组长度不能太短
也不能太长。既要便于操作与运算又要保证密码的安全性。本章将详细介绍几种分组密码算法：DES、3DES、AES和Blowfish。
分组密码算法一次只能处理固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组
密码算法进行迭代，以便将一段很长的明文全部加密，迭代的方法就称为分组密码的分组模式 (mode)。我们将把分组密码的
模式留在下一章进行讲解。

\stopsection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startsection[title={流密码：RC4},reference=sec:rc4]
\index{sec:rc4}

RC4 (Rivest Cipher 4) 是由罗纳德·李维斯特 (Ron Rivest) 在1987年开发出来的，RC4开始时是商业密码，没有
公开发表出来，但是在1994年9月份的时候，它被人匿名公开在了密码朋克 (Cypherpunks) 邮件列表上，随后又传播到了
互联网的许多站点被公开，RC4也就不再是商业秘密了，只是它的名字“RC4”仍然是一个注册商标。RC4已经成为一些常用的
协议和标准的一部分，如1997年的WEP和2003/2004年无线卡的WPA；和1995年的SSL，以及后来1999年的TLS。让它如此
广泛分布和使用的主要因素是它不可思议的简单和速度，不管是软件还是硬件，实现起来都十分容易。

RC4算法的原理很简单，包括{\it 初始化算法}（Key Scheduling Algorithm, KSA）和{\it 伪随机子密码生成算法}
(Pseudo Random Generation Algorithm, PRGA) 两大部分。


\startplacefigure[title={RC4初始化算法对S盒的初始化过程示意图}, reference=fig:rc4-init]
\midaligned{
\starttikzpicture
  [pre/.style={<-,shorten <=1pt,>=stealth',semithick},
  post/.style={->,shorten >=1pt,>=stealth',semithick},
  textnode/.style={draw=red!62.5!black, thick, fill=white!62.5!black, 
  minimum width=1.8em, minimum height=1.4em, font=\Tiny},
  plainnode/.style={minimum width=1.8em,minimum height=1.4em, font=\Tiny},
  node distance=-0.2mm]

  % S: initialization
  \node [plainnode] (S0) {\type{S}};
  \node [textnode,right=2mm of S0] (S0-0) {0};
  \node [textnode,right=of S0-0] (S0-1) {1};
  \node [textnode,right=of S0-1] (S0-2) {2};
  \node [textnode,right=of S0-2] (S0-3) {3};
  \node [textnode,right=of S0-3] (S0-4) {4};
  \node [plainnode,right=4.8cm of S0-4] (S0-dots) {.........};
  \node [textnode,right=4.8cm of S0-dots] (S0-253) {253};
  \node [textnode,right=of S0-253] (S0-254) {254};
  \node [textnode,right=of S0-254] (S0-255) {255};

  % K: seed key
  \node [plainnode,below=1cm of S0] (K) {\type{K}};
  \node [textnode,right=2mm of K] (K-0) {};
  \node [textnode,right=of K-0] (K-1) {};
  \node [textnode,right=of K-1] (K-2) {};
  \node [textnode,right=of K-2] (K-3) {};
  \node [plainnode,right=of K-3] (K-dots) {...};
  \node [textnode,right=of K-dots] (K-4) {};
  \path (K-0.north west) -- (K-4.north east) node [midway,plainnode,above] (K-len) {密钥长度Length(K)};
  \draw [name path=left-y,semithick] (K-0.north west) -- +(0, 0.5cm);
  \path [name path=left-x] (K-len.west) -- +(-3em, 0);
  \draw [name intersections={of=left-y and left-x,by=L}]
    [<-,shorten <=1pt,>=stealth',semithick] (L) -- (K-len.west);
  \draw [name path=right-y,semithick] (K-4.north east) -- +(0, 0.5cm);
  \path [name path=right-x] (K-len.east) -- +(3em, 0);
  \draw [name intersections={of=right-y and right-x,by=R}]
    [->,shorten >=1pt,>=stealth',semithick] (K-len.east) -- (R);

  % T: initialized by K
  \node [plainnode,below=1.5cm of K] (T) {\type{T}};
  \node [textnode,right=2mm of T] (T-00) {};
  \node [textnode,right=of T-00] (T-01) {};
  \node [textnode,right=of T-01] (T-02) {};
  \node [textnode,right=of T-02] (T-03) {};
  \node [plainnode,right=of T-03] (T-0dots) {...};
  \node [textnode,right=of T-0dots] (T-04) {};
  
  \node [textnode,right=of T-04] (T-10) {};
  \node [textnode,right=of T-10] (T-11) {};
  \node [textnode,right=of T-11] (T-12) {T[i]};
  \node [textnode,right=of T-12] (T-13) {};
  \node [plainnode,right=of T-13] (T-1dots) {...};
  \node [textnode,right=of T-1dots] (T-14) {};

  \path [name path=T-x] (T-14.east) -- +(7.8cm,0);
  \path [name path=S0-255-y] (S0-255.south) -- +(0,-3.5cm);
  \node [name intersections={of=T-x and S0-255-y,by=X}][textnode] (T-24) at (X) {};
  \node [plainnode,left=of T-24] (T-2dots) {...};
  \node [textnode,left=of T-2dots] (T-23) {};
  \node [textnode,left=of T-23] (T-22) {};
  \node [textnode,left=of T-22] (T-21) {};
  \node [textnode,left=of T-21] (T-20) {};
  \path (T-14.east) -- (T-20.west) node [midway,plainnode] (Tdots) {......};

  % K -> T
  \foreach \i in {0,1,2,3,4} {
    \draw [->,shorten >=1pt,>=stealth',semithick] (K-\i.south) -- (T-0\i.north);
    \coordinate (X-\i) at ($ (K-\i.south) + (0, -\i*1.5mm-4mm) $);
    \draw [->,shorten >=1pt,>=stealth',semithick] (X-\i) -| (T-1\i.north);
    \coordinate (Y-\i) at ($ (X-\i) + (6cm, 0) $);
    \draw [->,shorten >=1pt,>=stealth',semithick] (Y-\i) -| (T-2\i.north);
  }

  % calculate j
  \node [plainnode,below=0.8cm of T-12] (j) {j := (j + S[i] + T[i]) mod 256};

  % S randomization
  \node [plainnode, below=2cm of T] (S1) {\type{S}};
  \node [textnode,right=2mm of S1] (S1-0) {};
  \node [textnode,right=of S1-0] (S1-1) {};
  \node [textnode,right=of S1-1] (S1-2) {};
  \node [textnode,right=of S1-2] (S1-3) {};
  \node [textnode,right=of S1-3] (S1-4) {};
  \node [plainnode,right=of S1-4] (S1-5) {};
  \node [plainnode,right=of S1-5] (S1-6) {...};
  \node [plainnode,right=of S1-6] (S1-7) {};
  \node [textnode,below=2cm of T-12] (S1-i) {S[i]};

  \node [textnode,below=2cm of T-24] (S1-255) {};
  \node [textnode,left=of S1-255] (S1-254) {};
  \node [textnode,left=of S1-254] (S1-253) {};
  \path (S1-i.east) -- (S1-253.west) node [midway,textnode] (S1-j) {S[j]};
  \path (S1-i.east) -- (S1-j.west) node [midway,plainnode] (S1-dots1) {...};
  \path (S1-j.east) -- (S1-253.east) node [midway,plainnode] (S1-dots2) {...};
  \draw [->,shorten >=1pt,>=stealth',semithick] (T-12.south) -- (j.north);
  \draw [->,shorten >=1pt,>=stealth',semithick] (S1-i.north) -- (j.south);
  \draw [->,shorten >=1pt,>=stealth',semithick] (j.east) -| (S1-j.north);
  \draw [<->,shorten >=1pt,>=stealth',semithick] 
    (S1-i.south) .. controls +(-45:1cm) and +(-135:1cm) .. (S1-j.south)
    node [plainnode,above,midway] {交换};
\stoptikzpicture
}
\stopplacefigure


\startsubsection[title={初始化算法},reference=subsec:ksa]

RC4初始化阶段，由种子密钥\type{K}对一个称之为\type{S}盒的数组进行初始化。我们用\type{Length(K)}来表示
种子密钥的长度，并假设\type{S}盒的长度为256，RC4初始化过程可以用\in{图}[fig:rc4-init]和如下伪代码来描述。


\startpseudocode[before={\starttextrule{\small\bf RC4初始化算法的伪代码描述}}]
for i from 0 to 255 do
    S[i] := i
    T[i] := K[i mod Length(K)]

j := 0
for i from 0 to 255 do
    j := (j + S[i] + T[i]) mod 256
    swap values of S[i] and S[j]
\stoppseudocode

第一个\type{for}循环对\type{S}盒和数组\type{T}进行初始化。\type{S}盒中按顺序依次填入索引序号，种子
密钥\type{K}中的字节序列依次循环填入数组\type{T}来完成对\type{T}的初始化。第二个\type{for}循环
将\type{S}盒中的数值搅乱，\type{i}确保\type{S}中的每个元素都得到处理，\type{j}的选择通过种子密钥
\type{K}来保证\type{S}的搅乱是随机的。

\stopsubsection

\startsubsection[title={伪随机密码生成算法},referenc=subsec:prga]

在RC4伪随机密码生成算法阶段，基于初始化好的\type{S}盒，对明文流加密生成密文流。算法是一个迭代的过程，
\in{图}[fig:rc4-prga]给出了一次迭代过程的示意图，整个过程用如下伪代码描述。


\startplacefigure[title={RC4伪随机密码生成算法产生密文流的过程示意图}, reference=fig:rc4-prga]
\midaligned{
\starttikzpicture
  [pre/.style={<-,shorten <=1pt,>=stealth',semithick},
  post/.style={->,shorten >=1pt,>=stealth',semithick},
  textnode/.style={draw=red!62.5!black, thick, fill=white!62.5!black, 
  minimum width=1.8em, minimum height=1.4em, font=\Tiny},
  plainnode/.style={minimum width=1.8em,minimum height=1.4em, font=\Tiny},
  node distance=-0.2mm]

  \node [plainnode] (S) {\type{S}};
  \node [textnode,right=2mm of S] (S0) {};
  \node [textnode,right=of S0] (S1) {};
  \node [textnode,right=of S1] (S2) {};
  \node [textnode,right=of S2] (S3) {};
  \node [textnode,right=of S3] (S4) {};
  \node [plainnode,right=0.5cm of S4] (dots1) {...};
  \node [textnode,right=0.5cm of dots1] (Si) {S[i]};
  \node [plainnode,right=1.5cm of Si] (dots2) {...};
  \node [textnode,right=1.5cm of dots2] (Sj) {S[j]};
  \node [plainnode,right=0.5cm of Sj] (dots3) {...};
  \node [textnode,right=0.5cm of dots3] (Sk) {S[k]};
  \node [plainnode,right=0.5cm of Sk] (dots4) {...};
  \node [textnode,right=0.5cm of dots4] (S253) {};
  \node [textnode,right=of S253] (S254) {};
  \node [textnode,right=of S254] (S255) {};
  \node [plainnode] (j) at ($ (Si.north east) + (45:1cm) $) {j := (j + S[i]) mod 256};
  \draw [->,shorten >=1pt,>=stealth',semithick] (Si.east) -| (j.south);
  \draw [->,shorten >=1pt,>=stealth',semithick] (j.east) -| (Sj.north);
  \node [plainnode,below=1cm of dots2] (Sij) {k := (S[i] + S[j]) mod 256};
  \draw [<->,shorten >=1pt,>=stealth',semithick] 
    (Si.south) .. controls +(-30:1cm) and +(-150:1cm) .. (Sj.south)
    node [plainnode,above,midway] {交换};
  \draw [->,shorten >=1pt,>=stealth',semithick] 
    ($ (Si.south) + (-2mm, 0) $) -- ($ (Sij.north) + (-2.5mm, 0) $);
  \draw [->,shorten >=1pt,>=stealth',semithick] 
    ($ (Sj.south) + (2mm, 0) $) -- ($ (Sij.north) + (2.5mm, 0) $);
  \draw [->,shorten >=1pt,>=stealth',semithick] (Sij.east) -| ($ (Sk.south) + (-2mm, 0) $);
  \node [draw=red!62.5!black,thick,fill=white!62.5!black,
    shape=circle,below=1.5cm of Sk] (xor) {\type{+}} edge [pre] (Sk);
  \node [textnode,left=1cm of xor] (input) {inputByte} edge [post] (xor);
  \node [textnode,right=1cm of xor] (output) {outputByte} edge [pre] (xor);
\stoptikzpicture
}
\stopplacefigure

\startpseudocode[before={\starttextrule{\small\bf RC4伪随机密码生成算法的伪代码描述}}]
i := 0
j := 0
while (inputByte = readByte(inStream)) != EOF:
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    k := (S[i] + S[j]) mod 256
    outputByte = inputByte ^ S[k]
    writeByte(outStream, outputByte)
\stoppseudocode

每次迭代从明文流中读入一个字节，迭代结束之后生成一个密文字节输出到密文流中。每次迭代过程中，
由\type{i}和\type{j}两个指针索引\type{S}盒中相应的字节值。指针\type{i}在每次迭代前递增，
确保\type{S}盒中的每个位置的元素都有机会参与密文字节的计算。指针\type{i}指向的\type{S}盒中的元素进一步用于
计算指针\type{j}，用来“随机”挑选\type{S}盒中的另一个值。每次迭代，将\type{i}和\type{j}指向的\type{S}盒
中的两个元素相互交换来进一步打乱\type{S}盒，此步操作保证每256次迭代中\type{S}盒中的每个元素至少被交换过一次。
同时，用\type{i}和\type{j}指向的元素来计算另一个指针\type{k}，用\type{k}指向的\type{S}盒中的元素和明文流
中的当前读入的字节进行异或计算得到密文字节，并输出到密文流中。

PRGA生成密文流的过程中，只采用了异或运算，由于异或运算具有对称性，即由$a \oplus b = x$，可以得到
$x \oplus b = a$和$x \oplus a = b$。因此，RC4解密也使用同一套算法。

\stopsubsection

\startsubsection[title={使用OpenSSL进行RC4加密},reference=subsec:openssl-rc4]

OpenSSL是密码工作者和开发人员的必备利器，它是一个开放源代码的软件库包，整个软件包大概可以分成三个主要的
功能部分：
\startitemize[packed]
\item openssl命令行工具
\item libencrypt加密算法库
\item libssl加密模块应用库
\stopitemize

作为一个基于密码学的安全开发包，OpenSSL提供的功能相当强大和全面，囊括了主要的密码算法、常用的密钥和
证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。在介绍完每项具体的现代密码技术之后，
本书会使用OpenSSL来展示具体的例子，帮助读者加深对密码技术的理解。

在对称加密算法方面，OpenSSL一共提供了8种对称加密算法，其中7种是分组加密算法，仅有的一种流加密算法就是RC4。
下面展示用OpenSSL命令行工具完成RC4的加密和解密。

首先，我们使用\type{openssl}对字符串\type{hello}进行加密，指定加密算法为RC4。

\startshellcode
root@localhost:~# echo -ne "hello" | openssl enc -rc4 -K "DEADBEEF" -e -nosalt -p -out hello.rc4
key=DEADBEEF000000000000000000000000
\stopshellcode

\type{echo}命令输出的字符串\type{hello}通过管道传给\type{openssl}作为输入的明文字符串被加密，\type{-ne}
选项控制\type{echo}输出的字符串最后不自动添加换行符。\type{openssl}的\type{enc}子命令用于加密，这里，
我们通过\type{-rc4}选项指定了RC4算法，并指定了密钥是\type{DEADBEEF}，\type{openssl}会自动将密钥长度补齐
到128个比特位。\type{-e}是控制加密的选项参数，\type{-nosalt}表示不给密码加盐（后面，我们会详细讨论加盐密码）。
\type{-out}将加密后的密文输出到指定的文件中。

接下来，我们来看一下加密后的密文到底长得啥样。

\startshellcode
root@localhost:~# cat hello.rc4 | xxd
00000000: 7d5c e5fc 3b                             }\..;
\stopshellcode

我们将\type{hello.rc4}密文文件的内容读出来，并用\type{xxd}显示十六进制格式的密文字节，可以看到密文中有5个字节，
依次对应明文\type{hello}的5个字符。

最后，我们继续使用\type{openssl}命令对密文文件进行解密，并将解密后的结果输出到屏幕终端上。

\startshellcode
root@localhost:~# openssl enc -rc4 -K "DEADBEEF" -d -nosalt -p -in hello.rc4
key=DEADBEEF000000000000000000000000
hello
\stopshellcode

在命令行中，我们使用\type{-d}选项来表明解密操作，和加密操作一样，继续指定了RC4密码算法和密钥。并用\type{-in}选项
从文件\type{hello.rc4}中读入密文，最终还原出明文字符串\type{hello}。

\stopsubsection

\startsubsection[title={针对RC4的破解},reference=subsec:crack-rc4]

RC4算法是对称的加密算法，加密和解密的步骤都是众所周知的、固定不变的。唯一的保密性来自于种子密钥。理论上，
这个种子密钥只有通讯双方知道，但是如果第三方从某种途径获得了这个种子密钥，那么第三方可以毫不费力地用RC4来
解密他截获到的密文了。

理论上来说，RC4算法是很难被破解的。RC4中用到的种子密钥是长度在1到256之间可变的无类型字符序列，每个字节
有256种可能的取值，那么RC4算法的种子密钥的可能性就是
$256 + 256^2 + 256^3 + \cdots + 256^{256} \approx 256^{256}$
种可能性，量级在$10^{600}$以上。因此，针对RC4算法的暴力破解几乎是不可能的。

研究人员早前发现可以利用RC4中的统计偏差，导致可对加密信息中的一些伪随机字节能进行猜测。在2013年，科学家利用
这个漏洞设计了一次攻击实验：他们在2000小时内猜出一个基础身份认证cookie中包含的字符。后来技术改进后，研究人员
只需约75小时猜解就能得到$94\%$的准确率。

另外，新型针对WPA-TKIP网络的猜解攻击大概只需要花上1个小时的时间，攻击者可以任意注入、解密数据包。这项技术不仅
可以解密cookie和WiFi数据包，其他高速传输的加密数据流也有可能被解密。技术是通过向加密负载中注入数据，如每个认证
cookie或者WiFi数据包中的标准头部。攻击者会通过组合所有可能的值，通过使用统计偏差找出最有可能的组合。研究人员
表示，现在RC4加密已经不安全了，建议完全停止使用。在2015年由RFC~7465禁止在所有版本的TLS中使用。

\stopsubsection

\stopsection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startsection[title={分组密码：DES},reference=sec:des]
\index{sec:des}

1973年，美国国家标准局 (现在的美国国家标准技术研究所NIST, National Institute of Standards and Technology)
开始研究除国防部外的其它部门的计算机系统的数据加密标准，于1973年5月和1974年8月先后两次向公众发出了征求加密算法的
公告。加密算法要达到的目的主要为以下四点：
\startitemize[packed]
\item 提供高质量的数据保护，防止数据未经授权的泄露和未被察觉的修改； 
\item 具有相当高的复杂性，使得破译的开销超过可能获得的利益，同时又要便于理解和掌握；
\item 密码体制的安全性应该不依赖于算法的保密，其安全性仅以加密密钥的保密为基础；
\item 实现经济，运行有效，并且适用于多种完全不同的应用。
\stopitemize

1977年1月，美国政府采纳IBM公司设计的方案作为非机密数据的正式数据加密标准 (DES, Data Encryption Standard)，
DES被确定为美国联邦信息处理标准 (FIPS, Federal Information Processing Standard)，随后在国际上广泛流传开来。

DES算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局 (NSA, National Security Agency) 
的后门而在开始时有争议，DES因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。DES现在
已经不是一种安全的加密方法，1999年1月，distributed.net与电子前哨基金会合作，在22小时15分钟内即公开破解了一个
DES密钥。由于DES的密文可以在短时间内被破译，因此现在不应该再使用它了，在2001年，DES作为一个标准已经被AES所取代。
但是，作为现代密码技术的开山之作，我们还是要详细地介绍它的技术细节，其中，部分结构上的设计仍然被用于其他密码算法中。

\startsubsection[title={DES的总体结构},reference=subsec:des-structure]

DES是一个分组加密算法，以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥表面上是64位的，然而只有其中
的56位被实际用于加密计算，其余8位可以被用于奇偶校验，并在加密算法中被丢弃。因此，DES的有效密钥长度仅为56位。

\startplacefigure[title={DES总体结构图},reference=fig:des]
\midaligned{
\starttikzpicture
  [pre/.style={<-,shorten <=1pt,>=stealth',semithick},
  post/.style={->,shorten >=1pt,>=stealth',semithick},
  labelnode/.style={font=\Tiny},
  widetextnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black, 
  minimum width=6cm,minimum height=1.7em,font=\Tiny},
  halftextnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black, 
  minimum width=2.5cm,minimum height=1.7em,font=\Tiny},
  fnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,rounded corners=5pt,
  minimum width=8em,minimum height=1.7em,font=\Tiny},
  pc1node/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
  shape=trapezium,trapezium left angle=120,trapezium right angle=120,trapezium stretches body,
  minimum width=6cm,minimum height=1.7em,font=\Tiny},
  pc2node/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
  shape=trapezium,trapezium left angle=120,trapezium right angle=120,trapezium stretches body,
  minimum width=4cm,minimum height=1.7em,font=\Tiny},
  ipfpnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,rounded corners=5pt,
    minimum width=6cm,minimum height=1.7em,font=\Tiny},
  subkeynode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
    minimum width=4.5em,minimum height=1.7em,font=\Tiny},
  xornode/.style={shape=circle,draw=red!62.5!black,thick,fill=white!62.5!black,minimum size=1.7em},
  lshiftnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,rounded corners=5pt,
    minimum width=1cm,minimum height=1.7em,font=\Tiny},
  plainnode/.style={minimum width=1.8em,minimum height=1.7em,font=\Tiny},
  node distance=0.5cm]

  \node [widetextnode] (input) {明文分组 (64比特)};
  \node [ipfpnode, below=of input] (ip) {初始置换 (IP)} edge [pre] (input);
  \coordinate (ip-lh) at ($ (ip.south west) + (0.5cm, 0) $);
  \coordinate (ip-rh) at ($ (ip-lh) + (5cm, 0) $);
  \node [below=1pt,labelnode] at (ip-lh) {左半块 (32比特)};
  \node [below=1pt,labelnode] at (ip-rh) {右半块 (32比特)};

  \node [fnode, below=1.5cm of ip] (f1) {F函数 (第1轮)};
  \node [xornode, below=1.5cm of ip-lh] (xor1) {\type{+}} edge [pre] (f1);
  \coordinate (xor1-up) at ($ (xor1.north) + (0,0.5cm) $);
  \coordinate (xor1-down) at ($ (xor1.south) + (0,-0.5cm) $);
  \coordinate (f1-up) at ($ (xor1-up) + (5cm, 0) $);
  \coordinate (f1-down) at ($ (xor1-down) + (5cm, 0) $);

  \node [fnode, below=2cm of f1] (f2) {F函数 (第2轮)};
  \node [xornode, below=2cm of xor1] (xor2) {\type{+}} edge [pre] (f2);
  \coordinate (xor2-up) at ($ (xor2.north) + (0,0.5cm) $);
  \coordinate (xor2-down) at ($ (xor2.south) + (0,-0.5cm) $);
  \coordinate (f2-up) at ($ (xor2-up) + (5cm, 0) $);
  \coordinate (f2-down) at ($ (xor2-down) + (5cm, 0) $);

  \node [fnode, below=2cm of f2] (f16) {F函数 (第16轮)};
  \node [xornode, below=2cm of xor2] (xor16) {\type{+}} edge [pre] (f16);
  \coordinate (xor16-up) at ($ (xor16.north) + (0,0.5cm) $);
  \coordinate (xor16-down) at ($ (xor16.south) + (0,-0.5cm) $);
  \coordinate (f16-up) at ($ (xor16-up) + (5cm, 0) $);
  \coordinate (f16-down) at ($ (xor16-down) + (5cm, 0) $);

  \node [ipfpnode, below=of f16] (fp) {最终置换 (FP)};
  \node [widetextnode, below=of fp] (output) {密文分组 (64比特)} edge [pre] (fp);

  \draw [post] (ip-lh) -- (xor1.north);
  \draw [post] (ip-rh) |- (f1.east);

  \draw [post] (xor1.south) -- (xor1-down) -- (f2-up) |- (f2.east);
  \draw [post] (f1-up) -- (f1-down) -- (xor2-up) -- (xor2.north);

  \draw [semithick,loosely dash dot dot] (xor2.south) -- (xor2-down) -- (f16-up);
  \draw [post] (f16-up) |- (f16.east);
  \draw [semithick,loosely dash dot dot] (f2-up) -- (f2-down) -- (xor16-up);
  \draw [post] (xor16-up) -- (xor16.north);

  \draw [post] (xor16.south) -- +(0,-0.5cm);
  \draw [post] (f16-up) -- (f16-down);

  \node [widetextnode, right=2.5cm of input] (key) {密钥 (64比特)};
  \node [pc1node, below=of key] (pc1) {PC-1置换} edge [pre] (key);
  \coordinate (Loc-L1) at ($ (pc1.bottom left corner) + (0.5cm, -0.75cm) $);
  \coordinate (Loc-R1) at ($ (pc1.bottom right corner) + (-0.5cm, -0.75cm) $);
  \node at (Loc-L1) [lshiftnode] (L1) {左移};
  \node at (Loc-R1) [lshiftnode] (R1) {左移};
  \draw [post] ($ (pc1.bottom left corner) + (0.5cm, 0) $) -- node[labelnode]{$C_0$ (28比特)} (L1.north);
  \draw [post] ($ (pc1.bottom right corner) + (-0.5cm, 0) $) -- node[labelnode]{$D_0$ (28比特)} (R1.north);
  \node [pc2node, below=1.6cm of pc1] (pc2-1) {PC-2置换 (第1轮)};
  \coordinate (Loc-K1) at ($ (L1.south west) + (-1cm, -0.4cm) $);
  \node at (Loc-K1) [subkeynode] (K1) {子密钥K1};
  \draw [post] (L1.south) -- ++(0, -0.3cm) -- ++(1cm, 0) -- ++(0, -0.3cm);
  \draw [post] (R1.south) -- ++(0, -0.3cm) -- ++(-1cm, 0) -- ++(0, -0.3cm);
  \draw [post] (pc2-1.south) -- ++(0, -0.4cm) node[plainnode,midway,left=1pt] {48比特} -| (K1.south);

  \node [lshiftnode, below=2cm of L1] (L2) {左移} edge [pre] (L1);
  \node [lshiftnode, below=2cm of R1] (R2) {左移} edge [pre] (R1);
  \node [pc2node, below=2cm of pc2-1] (pc2-2) {PC-2置换 (第2轮)};
  \node [subkeynode, below=2cm of K1] (K2) {子密钥K2};
  \draw [post] (L2.south) -- ++(0, -0.3cm) -- ++(1cm, 0) -- ++(0, -0.3cm);
  \draw [post] (R2.south) -- ++(0, -0.3cm) -- ++(-1cm, 0) -- ++(0, -0.3cm);
  \draw [post] (pc2-2.south) -- ++(0, -0.4cm) node[plainnode,midway,left=1pt] {48比特} -| (K2.south);

  \node [lshiftnode, below=2cm of L2] (L16) {左移} edge [pre,loosely dash dot dot] (L2);
  \node [lshiftnode, below=2cm of R2] (R16) {左移} edge [pre,loosely dash dot dot] (R2);
  \node [pc2node, below=2cm of pc2-2] (pc2-16) {PC-2置换 (第16轮)};
  \node [subkeynode, below=2cm of K2] (K16) {子密钥K16};
  \draw [post] (L16.south) -- ++(0, -0.3cm) -- ++(1cm, 0) -- ++(0, -0.3cm);
  \draw [post] (R16.south) -- ++(0, -0.3cm) -- ++(-1cm, 0) -- ++(0, -0.3cm);
  \draw [post] (pc2-16.south) -- ++(0, -0.4cm) node[plainnode,midway,left=1pt] {48比特} -| (K16.south);
  \draw [post] (K1.north) -- +(0,0.5cm) -| (f1.north);
  \draw [post] (K2.north) -- +(0,0.5cm) -| (f2.north);
  \draw [post] (K16.north) -- +(0,0.5cm) -| (f16.north);
\stoptikzpicture
}
\stopplacefigure

DES算法的整体结构如\in{图}[fig:des]所示。在DES加密的过程中 (图的左半部分)，有16个相同的被称为
{\it 轮} (round) 的处理过程，并在首尾各有一次置换，分别称为初始置换 (IP, Initial Permutation)与
最终置换 (FP, Final Permutation)。首尾两次置换是互逆的，即最终置换可以还原初始置换后的原始
数据分组，反之亦然。

64位的数据分组在进入第一轮处理之前，被分成两个32位的半块分别处理。随后，每轮处理完后，左右两个半块交叉
作为下一轮处理的输入，这种多轮反复交叉的方式被称为{\it Feistel网络}，是由Horst Feistel设计发明的。
这一结构不仅被用于DES，在其他很多密码算法中也有应用。Feistel网络中每轮处理的\type{F}函数对数据分组的
右半块与该轮处理的子密钥进行运算。然后，\type{F}函数的输出与左半块进行异或操作之后，再与右半块
交叉作为下一轮的处理的两个输入半块。这种结构保证了加密和解密过程足够相似——唯一的区别在于在解密时子密钥
是以反向的顺序作用的，而剩余部分则完全相同。这样的设计大大简化了算法的实现，尤其是硬件实现，因为
不需要区分加密和解密算法。

Feistel网络中每轮处理所需要的子密钥由密钥调度算法(\in{}[subsec:des-ksa])根据密钥生成 
(\in{图}[fig:des]的右半部分)。下面，对DES每个处理的细节一一进行详细的介绍。

\startplacefigure[title={初始置换和最终置换},reference=fig:des-ipfp]
\startcombination[1*2]{
\starttikzpicture
  [pre/.style={<-,shorten <=1pt,>=stealth',semithick},
  post/.style={->,shorten >=1pt,>=stealth',semithick},
  labelnode/.style={font=\Tiny},
  bodynode/.style={draw=red!62.5!black,thick,fill=white!62.5!black, 
  minimum width=11cm,minimum height=1.2cm},
  pinnode/.style={draw=red!62.5!black,thick,fill=yellow!62.5!black, 
  minimum width=2mm,minimum height=2mm},
  labelnode/.style={font=\Tiny},
  node distance=0.2cm]
  
  \node [bodynode] at (5.5cm,0.6cm) {};
  \foreach \i in {0,1,2,...,21} {
    \ifnum \i < 2
      \node [pinnode] (in-\i) at (0.25cm+\i*0.5cm,1.2cm) {};
      \node [pinnode] (out-\i) at (0.25cm+\i*0.5cm,0) {};
    \else
      \pgfmathmod{\i-2}{4}
      \let\m\pgfmathresult
      \pgfmathparse{int(\m)}
      \let\r\pgfmathresult
      \ifnum \r = 1
        \node [labelnode] at (0.25cm+\i*0.5cm, 1.4cm) {\dots};
        \node [labelnode] at (0.25cm+\i*0.5cm, -0.2cm) {\dots};
      \else
        \ifnum \r = 3
          \node [pinnode] (in-\i) at (0.25cm+\i*0.5cm,1.2cm) {};
          \node [pinnode] (out-\i) at (0.25cm+\i*0.5cm,0) {};
        \fi
      \fi
    \fi
  }

  \foreach \i/\b in {0/1,1/2,5/8,9/25,13/40,17/58,21/64} {
    \node [labelnode,above=of in-\i] (bin-\b) {\b} edge [semithick] (in-\i);
    \node [labelnode,below=of out-\i] (bout-\b) {\b} edge [semithick] (out-\i);
  }

  \draw [post] (in-0.south) -- +(0,-2mm) -- ($ (out-13.north) + (0,3mm) $) -- (out-13.north);
  \draw [post] (in-1.south) -- +(0,-2mm) -- ($ (out-5.north) + (0,3mm) $) -- (out-5.north);
  \draw [post] (in-17.south) -- +(0,-2mm) -- ($ (out-0.north) + (0,3mm) $) -- (out-0.north);
  \draw [post] (in-21.south) -- +(0,-2mm) -- ($ (out-9.north) + (0,3mm) $) -- (out-9.north);
\stoptikzpicture
}{\Tiny 初始置换}
{
  \starttikzpicture
  [pre/.style={<-,shorten <=1pt,>=stealth',semithick},
  post/.style={->,shorten >=1pt,>=stealth',semithick},
  labelnode/.style={font=\Tiny},
  bodynode/.style={draw=red!62.5!black,thick,fill=white!62.5!black, 
  minimum width=11cm,minimum height=1.2cm},
  pinnode/.style={draw=red!62.5!black,thick,fill=yellow!62.5!black, 
  minimum width=2mm,minimum height=2mm},
  labelnode/.style={font=\Tiny},
  node distance=0.2cm]
  
  \node [bodynode] at (5.5cm,0.6cm) {};
  \foreach \i in {0,1,2,...,21} {
    \ifnum \i < 2
      \node [pinnode] (in-\i) at (0.25cm+\i*0.5cm,1.2cm) {};
      \node [pinnode] (out-\i) at (0.25cm+\i*0.5cm,0) {};
    \else
      \pgfmathmod{\i-2}{4}
      \let\m\pgfmathresult
      \pgfmathparse{int(\m)}
      \let\r\pgfmathresult
      \ifnum \r = 1
        \node [labelnode] at (0.25cm+\i*0.5cm, 1.4cm) {\dots};
        \node [labelnode] at (0.25cm+\i*0.5cm, -0.2cm) {\dots};
      \else
        \ifnum \r = 3
          \node [pinnode] (in-\i) at (0.25cm+\i*0.5cm,1.2cm) {};
          \node [pinnode] (out-\i) at (0.25cm+\i*0.5cm,0) {};
        \fi
      \fi
    \fi
  }

  \foreach \i/\b in {0/1,1/2,5/8,9/25,13/40,17/58,21/64} {
    \node [labelnode,above=of in-\i] (bin-\b) {\b} edge [semithick] (in-\i);
    \node [labelnode,below=of out-\i] (bout-\b) {\b} edge [semithick] (out-\i);
  }

  \draw [post] (in-0.south) -- +(0,-2mm) -- ($ (out-17.north) + (0,3mm) $) -- (out-17.north);
  \draw [post] (in-5.south) -- +(0,-2mm) -- ($ (out-1.north) + (0,3mm) $) -- (out-1.north);
  \draw [post] (in-9.south) -- +(0,-2mm) -- ($ (out-21.north) + (0,3mm) $) -- (out-21.north);
  \draw [post] (in-13.south) -- +(0,-2mm) -- ($ (out-0.north) + (0,3mm) $) -- (out-0.north);
\stoptikzpicture
}{\Tiny 最终置换}
\stopcombination
\stopplacefigure

\stopsubsection

\startsubsection[title={初始置换和最终置换},reference=subsec:permutation]

64位明文分组经过初始置换，生成重新排列之后的64位数据分组。如\in{图}[fig:des-ipfp]所示，这个初始置换对
明文分组的64个比特重新排列。排列后的数据分组分成左右两个各32位的半块，输入到Feistel网络中经过16轮\type{F}函数
的运算，最后由最终置换再次重新排列，输出64位密文分组。由\in{图}[fig:des-ipfp]可以看出，初始置换和最终置换
是互逆的，这就满足了加密和解密对称性的必要条件。

\stopsubsection

\startsubsection[title={Feistel网络},reference=subsec:feistel]

从\in{图}[fig:des]所示的DES的总体结构图中，我们了解到明文分组经过初始置换之后，分成两个32位的半块进入
Feistel网络。Feistel网络是由16轮\type{F}函数串联组成的计算过程。在Feistel网络中，每一轮都需要
使用一个不同的子密钥，我们会随后的\in[subsec:des-ksa]{密钥调度}这一小节再详细介绍子密钥的生成算法。
这里，我们要注意的是，每一轮子密钥的长度均为48位，它和32位的右半块作为\type{F}函数的输入，经过计算处理
输出长32位的比特序列再和32位的左半块进行异或计算。该异或计算得到的32位比特序列，在进入下一轮处理之前和
右半块进行对调。

总结一下，一轮的具体计算步骤如下：
\startitemize[n,packed]
\item 将输入数据分组分成左右两个均为32位的半块。
\item 右半块不经任何处理直接作为\type{F}函数的输入。
\item \type{F}函数根据右半块和该轮子密钥，计算出长32位的比特序列。
\item 将上一步得到的比特序列和左半块进行异或计算，其结果作为下一轮处理的右半块。
\item 该轮右半块不经任何处理直接发送到下一轮，作为下一轮处理的左半块。
\stopitemize

\startplacefigure[title={\type{F}函数计算过程图},reference=fig:des-func]
\midaligned{
\starttikzpicture
[pre/.style={<-,shorten <=1pt,>=stealth',semithick},
post/.style={->,shorten >=1pt,>=stealth',semithick},
labelnode/.style={font=\Tiny},
sboxesnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
minimum width=6cm,minimum height=2em,font=\Tiny},
sboxnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
minimum width=1.4em,minimum height=1.4em,font=\Tiny},
epboxnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
shape=trapezium,trapezium left angle=60,trapezium right angle=60,trapezium stretches body,
minimum width=6cm,minimum height=1.7em,font=\Tiny},
spboxnode/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
minimum width=6cm,minimum height=1.7em,font=\Tiny},
xornode/.style={shape=circle,draw=red!62.5!black,thick,fill=white!62.5!black,minimum size=1.7em},
every label/.style={font=\Tiny},
node distance=0.5cm]
\node [labelnode] (in) {右半块 (32比特)};
\node [epboxnode, below=1cm of in] (epbox) {扩展置换} edge [pre] (in);
\node [xornode, below=of epbox] (xor) {\type{+}} edge [pre] node [right=1pt,labelnode] {48比特} (epbox);
\node [labelnode, right=3.6cm of xor] (subkey) {子密钥 (48比特)} edge [post] (xor);
\node [sboxesnode, below=of xor, label=above left:S置换盒] (sboxes) {} edge [pre] (xor);
\node [sboxnode,right=2.5mm of sboxes.west] (s1) {\type{S}};
\foreach \i/\j in {2/1,3/2,4/3,5/4,6/5,7/6,8/7} {
  \node [sboxnode, right=2mm of s\j] (s\i) {\type{S}};
}
\node [spboxnode, below=of sboxes] (pbox) {P置换} edge [pre] node [right=1pt,labelnode] {32比特} (sboxes);
\node [labelnode, below=1cm of pbox] (out) {32位的比特序列} edge [pre] (pbox);

\startscope [on background layer]
  \node
  [fill=white!62.5!black, draw=red!62.5!black, very thick, inner sep=0.5cm, 
   rounded corners, 
   fit=(epbox) (pbox),
   label=above left:F函数] {};
\stopscope
\stoptikzpicture
}
\stopplacefigure

Feistel网络一轮计算中最核心的部分是\type{F}函数，包含了多个装置：扩展置换、\type{S}盒置换和
\type{P}置换。其计算过程可以用\in{图}[fig:des-func]来描述，具体如下：

\startitemize[n,packed]
\item 右半块32位的比特序列，经过扩展置换扩展为48位的比特序列。
\item 右半块被扩展后的48位比特序列和子密钥进行异或计算，得到另一个48位的比特序列。
\item 在上一步异或计算得到的48位比特序列，经过\type{S}置换盒后，输出32位的比特序列。
\item 最后，\type{P}置换把32位的比特序列再次打乱，输出\type{F}函数的处理结果。
\stopitemize

下面，我们来详细介绍\type{F}函数中每个装置的具体操作方法。

{\bf (1) 扩展置换}

扩展置换将32位的半块扩展到48位。如\in{图}[fig:des-expan-p]所示，32位的半块在置换前被分成
8个4位的小分组，置换后输出8个6位的小分组。输出的每个6位的小分组中有4位直接对应输入小分组，
首末2位则分别来自于前后两个相邻输入小分组中紧邻的首末位。

\startplacefigure[title={扩展置换原理图},reference={fig:des-expan-p}]
\midaligned{
\starttikzpicture
[pre/.style={<-,shorten <=1pt,>=stealth',semithick},
post/.style={->,shorten >=1pt,>=stealth',semithick},
labelnode/.style={font=\Tiny},
innode/.style={draw=red!62.5!black,thick,fill=yellow!62.5!black,
minimum width=0.75em,minimum height=0.75em,font=\Tiny},
outnode/.style={draw=red!62.5!black,thick,fill=green!62.5!black,
minimum width=0.75em,minimum height=0.75em,font=\Tiny},
blanknode/.style={minimum width=0.75em,minimum height=0.75em,font=\Tiny},
node distance=-1pt]
\foreach \g in {1,2,...,8} {
  \ifnum \g = 1
    \foreach \i in {1,2,...,6} {
      \ifnum \i = 1
        \node [outnode] (out-\g-\i) {};
      \else
        \pgfmathsubtract{\i}{1}
        \pgfmathparse{int(\pgfmathresult)}
        \let\j\pgfmathresult
        \node [outnode, right=of out-\g-\j] (out-\g-\i) {};
        \ifnum \i < 6
          \node [innode, above=1cm of out-\g-\i] (in-\g-\i) {} edge [post] (out-\g-\i);
        \fi
      \fi
    }
  \else
    \pgfmathsubtract{\g}{1}
    \pgfmathparse{int(\pgfmathresult)}
    \let\h\pgfmathresult
    \foreach \i in {1,2,...,6} {
      \ifnum \i = 1
        \node [outnode, right=of blank-\h] (out-\g-\i) {};
      \else
        \pgfmathsubtract{\i}{1}
        \pgfmathparse{int(\pgfmathresult)}
        \let\j\pgfmathresult
        \node [outnode, right=of out-\g-\j] (out-\g-\i) {};
        \ifnum \i < 6
          \node [innode, above=1cm of out-\g-\i] (in-\g-\i) {} edge [post] (out-\g-\i);
        \fi
      \fi
    }
  \fi
  \node [blanknode,right=of out-\g-6] (blank-\g) {};
}

\foreach \g in {1,2,...,8} {
  \ifnum \g < 8
    \pgfmathadd{\g}{1}
    \pgfmathparse{int(\pgfmathresult)}
    \let\h\pgfmathresult
    \draw [post] (in-\g-5.south east) -- +(2pt,-3mm) -- 
      ($ (out-\h-1.north) + (0,3mm) $) -- (out-\h-1.north);
  \fi

  \ifnum \g > 1
    \pgfmathsubtract{\g}{1}
    \pgfmathparse{int(\pgfmathresult)}
    \let\h\pgfmathresult
    \draw [post] (in-\g-2.south west) -- +(-2pt,-3mm) -- 
      ($ (out-\h-6.north) + (0,3mm) $) -- (out-\h-6.north);
  \fi
}

\draw [post] (in-1-2.north) -- ++(0,2mm) -| (out-8-6.north);
\draw [post] (in-8-5.north) -- ++(0,4mm) -| (out-1-1.north);
\node [labelnode,left=1mm of out-1-1] (out) {48位的比特序列 (输出)};
\node [labelnode,left=3.5mm of in-1-2] (in) {32位的比特序列 (输入)};
\stoptikzpicture
}
\stopplacefigure

% 扩展置换也可以用\in{表}[tab:expan-p]描述。表中的行代表每个小分组，列代表小分组中每个比特的位置，
% 第一列和最后一列用{\darkgreen 绿底色}高亮，表明这两列只在扩展置换输出后的小分组中。表中数值代表
% 置换后比特序列的相应比特位中来自于输入比特序列的哪个比特位。

% \placetable
%   [here][tab:expan-p]
%   {扩展置换表}{%
%   \switchtobodyfont[8pt]
%   % \setupTABLE[row][height=1.4em]
%   \setupTABLE[column][width=3em,align=center]
%   \setupTABLE[column][first,last][background=color,backgroundcolor=darkgreen,color=white]
%   % \setupTABLE[column][last][background=color,backgroundcolor=darkgreen]
%   \bTABLE
%   % \bTR \bTH 32 \eTH \bTH bb \eTH \bTH cc \eTH \bTH dd \eTH \eTR
%   \bTR \bTD 32 \eTD \bTD 01 \eTD \bTD 02 \eTD \bTD 03 \eTD \bTD 04 \eTD \bTD 05 \eTD \eTR
%   \bTR \bTD 04 \eTD \bTD 05 \eTD \bTD 06 \eTD \bTD 07 \eTD \bTD 08 \eTD \bTD 09 \eTD \eTR
%   \bTR \bTD 08 \eTD \bTD 09 \eTD \bTD 10 \eTD \bTD 11 \eTD \bTD 12 \eTD \bTD 13 \eTD \eTR
%   \bTR \bTD 12 \eTD \bTD 13 \eTD \bTD 14 \eTD \bTD 15 \eTD \bTD 16 \eTD \bTD 17 \eTD \eTR
%   \bTR \bTD 16 \eTD \bTD 17 \eTD \bTD 18 \eTD \bTD 19 \eTD \bTD 20 \eTD \bTD 21 \eTD \eTR
%   \bTR \bTD 20 \eTD \bTD 21 \eTD \bTD 22 \eTD \bTD 23 \eTD \bTD 24 \eTD \bTD 25 \eTD \eTR
%   \bTR \bTD 24 \eTD \bTD 25 \eTD \bTD 26 \eTD \bTD 27 \eTD \bTD 28 \eTD \bTD 29 \eTD \eTR
%   \bTR \bTD 28 \eTD \bTD 29 \eTD \bTD 30 \eTD \bTD 31 \eTD \bTD 32 \eTD \bTD 01 \eTD \eTR
%   \eTABLE
% }

{\bf (2) \type{S}置换}

扩展置换后输出的48位比特序列和子密钥经过异或计算之后，由\type{S}置换转换回32位的比特序列。
\type{S}置换操作前，先将48位的比特序列分成8个6位的小分组。\type{S}置换操作包含8个\type{S}盒，
每个\type{S}盒分别负责一个小分组的转换。\type{S}盒以查找表的方式提供非线性的变换将它的6个输入位变成
4个输出位。

\startplacefigure[title={\type{S}盒将6位的比特序列转换为4位的比特序列},reference=fig:des-sbox]
\midaligned{
\starttikzpicture
[pre/.style={<-,shorten <=1pt,>=stealth',semithick},
post/.style={->,shorten >=1pt,>=stealth',semithick},
labelnode/.style={font=\Tiny,inner sep=0},
innode1/.style={draw=red!62.5!black,thick,fill=green!62.5!black,
minimum width=0.75em,minimum height=0.75em,font=\Tiny},
innode2/.style={draw=red!62.5!black,thick,fill=yellow!62.5!black,
minimum width=0.75em,minimum height=0.75em,font=\Tiny},
outnode/.style={draw=red!62.5!black,thick,fill=orange!62.5!black,
minimum width=0.75em,minimum height=0.75em,font=\Tiny},
inmux1/.style={shape=isosceles triangle,anchor=lower side,shape border rotate=-90,
isosceles triangle stretches,
draw=red!62.5!black,thick,fill=yellow!62.5!black,
minimum width=3.5cm,minimum height=0.2cm},
inmux2/.style={shape=isosceles triangle,isosceles triangle stretches,
draw=red!62.5!black,thick,fill=green!62.5!black,
minimum width=1cm,minimum height=0.05cm},
outmux/.style={shape=isosceles triangle,anchor=apex,shape border rotate=90,
isosceles triangle stretches,
draw=red!62.5!black,thick,fill=orange!62.5!black,
minimum width=3.5cm,minimum height=1.5cm},
table/.style={draw=red!62.5!black,thick,fill=white!62.5!black,
minimum width=8cm,minimum height=2cm},
node distance=0.5cm]
\node [innode1] (in-b1) {};
\node [innode2, right=of in-b1] (in-b2) {};
\node [innode2, right=of in-b2] (in-b3) {};
\node [innode2, right=of in-b3] (in-b4) {};
\node [innode2, right=of in-b4] (in-b5) {};
\node [innode1, right=of in-b5] (in-b6) {};
\foreach \l in {1,2,...,6} {
  \node [labelnode, above=of in-b\l] (inlabel-b\l) {b\l} edge [post] (in-b\l);
}
\coordinate (top-middle) at ($ 1/2*(in-b3.east) + 1/2*(in-b4.west) $);
\node [inmux1, below=1cm of top-middle] (in-mux1) {};

\node [table,below=of in-mux1] (table) {};
\foreach \i in {1,2,3} {
  \pgfmathsubtract{4}{\i}
  \pgfmathparse{int(\pgfmathresult)}
  \let\r\pgfmathresult
  \coordinate (left-\i) at ($ \r/4*(table.north west) + \i/4*(table.south west) $);
  \coordinate (right-\i) at ($ \r/4*(table.north east) + \i/4*(table.south east) $);
  \draw [red!62.5!black,dotted] (left-\i) -- (right-\i);
}
\foreach \j in {1,2,...,15} {
  \pgfmathsubtract{16}{\j}
  \pgfmathparse{int(\pgfmathresult)}
  \let\c\pgfmathresult
  \coordinate (top-\j) at ($ \c/16*(table.north west) + \j/16*(table.north east) $);
  \coordinate (bottom-\j) at ($ \c/16*(table.south west) + \j/16*(table.south east) $);
  \draw [red!62.5!black,dotted] (top-\j) -- (bottom-\j);
}

\node [inmux2, left=of table] (in-mux2) {};

\draw [post] (in-b2.south) -- +(0, -9mm);
\draw [post] (in-b3.south) -- +(0, -9mm);
\draw [post] (in-b4.south) -- +(0, -9mm);
\draw [post] (in-b5.south) -- +(0, -9mm);
\draw [post] (in-b1.south) -- ++(0, -0.25cm) -- ++(-3.8cm, 0) |- (in-mux2.south west);
\draw [post] (in-b6.south) -- ++(0, -0.5cm) -- ++(-7.5cm, 0) |- (in-mux2.north west);

% row index on left
\coordinate (left-0) at (table.north west);
\foreach \i in {0,1,2,3} {
  \node [labelnode, below left=6pt of left-\i] (label-r\i) {\i};
}

% column index on top
\coordinate (top-0) at (table.north west);
\foreach \j in {0,1,...,15} {
  \ifnum \j < 10
    \node [labelnode, above right=4pt of top-\j] (label-c\i) {~\j};
  \else
    \node [labelnode, above right=4pt of top-\j] (label-c\i) {\j};
  \fi
}

\path [name path=l2-r2] (left-2) -- (right-2);
\path [name path=t7-b7] (top-7) -- (bottom-7);
\fill [name intersections={of=l2-r2 and t7-b7, by=x},red!62.5!black] (x) rectangle +(5mm,5mm);
\node [outmux] at ($ (x) + (2.5mm,0) $) (out-mux) {};
\coordinate (mux-b1) at ($ (out-mux.left corner) + (2.5mm,0) $);
\coordinate (mux-b4) at ($ (out-mux.right corner) + (-2.5mm,0) $);
\coordinate (mux-b2) at ($ 2/3*(mux-b1) + 1/3*(mux-b4) $);
\coordinate (mux-b3) at ($ 1/3*(mux-b1) + 2/3*(mux-b4) $);

\foreach \i in {1,2,3,4} {
  \node [outnode, below=of mux-b\i] (out-b\i) {} edge [pre] (mux-b\i);
  \node [labelnode, below=of out-b\i] (outlabel-b\i) {b\i} edge [pre] (out-b\i);
}

\startscope [on background layer]
  \filldraw
  [fill=white!62.5!black, draw=red!62.5!black, very thick,
   rounded corners] 
   (in-b1.base) -- (in-b6.base) -- +(2.5cm,0) |- (out-b4.base) -- (out-b1.base) -- +(-4.5cm,0) |- cycle;
  \node [label=above:S盒] at ($ (in-b1.base) + (-3.5cm,0) $) {};
\stopscope
\stoptikzpicture
}
\stopplacefigure

\in{图}[fig:des-sbox]解释了将6位比特序列置换成4位比特序列的操作原理。\type{S}盒中内置了一个4行16列的
替换表，表中元素均为0至15的数 (4个比特)。6位比特序列的首尾两个比特组成行索引值，中间4个比特组成列索引值，
用于定位替换表中的元素，作为输出的比特序列。\type{S}盒提供了DES的核心安全性——如果没有S盒，密码会是线性的，
很容易破解。

{\bf (3) \type{P}置换}

\type{P}置换本质上是一个替换表，将\type{S}盒置换后输出的32位比特序列按照\in{图}[fig:des-p]重新排列为另一个
32位的比特序列。\type{P}置换后的32位比特序列就是\type{F}函数的输出。

\startplacefigure[title={\type{P}置换原理图},reference=fig:des-p]
\startcombination[1*2]
{
\starttikzpicture
[pre/.style={<-,shorten <=1pt,>=stealth',semithick},
 post/.style={->,shorten >=1pt,>=stealth',semithick},
 labelnode/.style={font=\Tiny},
 innode/.style={shape=circle,draw=red!62.5!black,thick,fill=yellow!62.5!black,minimum size=1em},
 outnode/.style={shape=circle,draw=red!62.5!black,thick,fill=green!62.5!black,minimum size=1em},
 labelnode/.style={font=\Tiny},
 node distance=2pt]
% used for anchor
\node (in-0) {};

\foreach \i in {1,2,...,32} {
  \pgfmathsubtract{\i}{1}
  \pgfmathparse{int(\pgfmathresult)}
  \let\j\pgfmathresult
  \node [innode,right=of in-\j] (in-\i) {};
  \node [outnode,below=2cm of in-\i] (out-\i) {};
  \node [labelnode,above=0pt of in-\i] (inlabel-\i) {\i};
  \node [labelnode,below=0pt of out-\i] (outlabel-\i) {\i};
}

\foreach \i/\j in {16/1,7/2,20/3,21/4,29/5,12/6,28/7,17/8,
  1/9,15/10,23/11,26/12,5/13,18/14,31/15,10/16,2/17,8/18,
  24/19,14/20,32/21,27/22,3/23,9/24,19/25,13/26,30/27,6/28,
  22/29,11/30,4/31,25/32} {
  \draw [post] (in-\i.south) -- (out-\j.north);
}
\stoptikzpicture
}{}
{
\switchtobodyfont[6pt]
\setupTABLE[row][1][background=color,backgroundcolor=darkyellow,color=white]
\setupTABLE[row][2][background=color,backgroundcolor=darkgreen,color=white]
\setupTABLE[column][width=2.12em,align=center]
\setupTABLE[framecolor=black,rulethickness=0.5pt]
\bTABLE
\bTR \bTD 16 \eTD \bTD 07 \eTD \bTD 20 \eTD \bTD 21 \eTD \bTD 29 \eTD \bTD 12 \eTD \bTD 28 \eTD \bTD 17 \eTD 
     \bTD 01 \eTD \bTD 15 \eTD \bTD 23 \eTD \bTD 26 \eTD \bTD 05 \eTD \bTD 18 \eTD \bTD 31 \eTD \bTD 10 \eTD 
     \bTD 02 \eTD \bTD 08 \eTD \bTD 24 \eTD \bTD 14 \eTD \bTD 32 \eTD \bTD 27 \eTD \bTD 03 \eTD \bTD 09 \eTD 
     \bTD 19 \eTD \bTD 13 \eTD \bTD 30 \eTD \bTD 06 \eTD \bTD 22 \eTD \bTD 11 \eTD \bTD 04 \eTD \bTD 25 \eTD \eTR
\bTR \bTD 01 \eTD \bTD 02 \eTD \bTD 03 \eTD \bTD 04 \eTD \bTD 05 \eTD \bTD 06 \eTD \bTD 07 \eTD \bTD 08 \eTD 
     \bTD 09 \eTD \bTD 10 \eTD \bTD 11 \eTD \bTD 12 \eTD \bTD 13 \eTD \bTD 14 \eTD \bTD 15 \eTD \bTD 16 \eTD 
     \bTD 17 \eTD \bTD 18 \eTD \bTD 19 \eTD \bTD 20 \eTD \bTD 21 \eTD \bTD 22 \eTD \bTD 23 \eTD \bTD 24 \eTD 
     \bTD 25 \eTD \bTD 26 \eTD \bTD 27 \eTD \bTD 28 \eTD \bTD 29 \eTD \bTD 30 \eTD \bTD 31 \eTD \bTD 32 \eTD \eTR
\eTABLE
}{}
\stopcombination
\stopplacefigure

至此，我们已经完成了对\type{F}函数的详细探讨。尽管\type{F}函数稍显复杂，包含多次置换和非线性变换等操作，
我们化繁为简，对每个操作进行了详细的解释，以帮助大家更容易理解这些细节。最后，我们来回顾和总结
一下Feistel网络的特点。

首先，Feistel网络的轮数不会对加解密产生影响，轮数可以任意增加，无论运行多少轮的计算，都不会发生无法解密
的情况。

其次，每轮\type{F}函数的设计也不会对加解密产生影响。\type{F}函数可以不用被设计成可逆函数，即就算
用\type{F}函数的输出不能计算出其输入，也不会出现无法解密的问题。所以，\type{F}函数可以被设计得任意复杂。

另外，加密和解密可以用完全相同的结构来实现，这也是Feistel网络的一个重要特征。在Feistel网络的一轮中，
右半分组实际上没有做任何处理，这样就迫使加密算法不得不使用多轮迭代处理来提高密文的保密程度，这看起来非常
浪费时间，但却保证了可解密性。因为完全没有被处理的右半分组，是解密过程中所必需的信息。由于加密和解密
可以用完全相同的结构来实现，因此用于实现DES算法的硬件设备的设计也非常容易。

综上所述，无论多少轮数、采用什么\type{F}函数，Feistel网络都可以用相同的结构实现加密和解密，且加密
的结果必定能正确解密。

\stopsubsection

\startsubsection[title={密钥调度},reference=subsec:des-ksa]

密钥调度为DES加密算法生成Feistel网络16轮加密处理中每轮处理所需要的子密钥，其过程如\in{图}[fig:des]的
右半部所示。DES密钥调度主要包含2种置换：{\it PC-1置换}和{\it PC-2置换}。

{\bf (1) PC-1置换}

\in{图}[fig:des-pc1]解释了PC-1置换的原理，图中小圆圈内的数字表示密钥比特序列的位置。初始密钥的每第8个
比特在PC-1置换中被舍弃，随后重新排列生成56位的比特序列。因此，DES密钥实际的有效长度为56位。PC-1置换完成
后得到的56位比特序列分成两个28位的半密钥块$C_0$和$D_0$。在剩下的16轮子密钥生成过程中，两个半密钥块均先
被循环左移1或2位（第1、2、9、16轮左移1位，其他轮左移2位）后，由PC-2置换输出该轮的48位子密钥。

\startplacefigure[title={PC-1置换},reference=fig:des-pc1]
\midaligned{
\starttikzpicture
[pre/.style={<-,shorten <=1pt,>=stealth',semithick},
 post/.style={->,shorten >=1pt,>=stealth',semithick},
 labelnode/.style={font=\switchtobodyfont[6pt]},
 innode/.style={shape=circle,draw=red!62.5!black,thick,fill=yellow!62.5!black,
 minimum size=1.2em,font=\switchtobodyfont[6pt],inner sep=0},
 dropnode/.style={shape=circle,draw=red!62.5!black,thick,fill=black,
 minimum size=1.2em,font=\switchtobodyfont[6pt],inner sep=0,text=white},
 outnode/.style={shape=circle,draw=red!62.5!black,thick,fill=green!62.5!black,
 minimum size=1.2em,font=\switchtobodyfont[6pt],inner sep=0},
 arrow/.style={shape=single arrow,draw=red!62.5!black,thick,
 minimum height=1cm,minimum width=2.5cm,single arrow head extend=1mm,
 single arrow tip angle=130,
 shade,shading=axis,left color=yellow!62.5!black,right color=green!62.5!black},
 labelnode/.style={font=\Tiny},
 node distance=4pt]
\startscope
% anchor node
\node (in-10) {};
\foreach \i in {1,2,...,8} {
  \pgfmathsubtract{\i}{1}
  \pgfmathparse{int(\pgfmathresult)}
  \let\k\pgfmathresult
  \foreach \j in {1,2,...,8} {
    \pgfmathsubtract{\j}{1}
    \pgfmathparse{int(\pgfmathresult)}
    \let\l\pgfmathresult

    \pgfmathmultiply{\k}{8}
    \pgfmathparse{int(\pgfmathresult)}
    \pgfmathadd{\pgfmathresult}{\j}
    \pgfmathparse{int(\pgfmathresult)}
    \let\v\pgfmathresult

    \ifnum \j = 1
      \ifnum \i = 1
        \node [innode,right=of in-\i\l] (in-\i\j) {\v};
      \else
        \node [innode,below=of in-\k\j] (in-\i\j) {\v};
      \fi
    \else
      \ifnum \j = 8
        \node [dropnode,right=of in-\i\l] (in-\i\j) {\v};
        \draw [white] (in-\i\j.north east) -- (in-\i\j.south west);
        \draw [white] (in-\i\j.north west) -- (in-\i\j.south east);
      \else
        \node [innode,right=of in-\i\l] (in-\i\j) {\v};
      \fi
    \fi
  }
}
\stopscope

\node [arrow,xshift=5.4cm,yshift=-2cm] {};

\startscope[xshift=6cm]
% anchor node
\node (in-10) {};
\foreach \x/\t in {1/57,2/49,3/41,4/33,5/25,6/17,7/9,8/,
  9/1,10/58,11/50,12/42,13/34,14/26,15/18,16/,
  17/10,18/2,19/59,20/51,21/43,22/35,23/27,24/,
  25/19,26/11,27/3,28/60,29/52,30/44,31/36,32/,
  33/63,34/55,35/47,36/39,37/31,38/23,39/15,40/,
  41/7,42/62,43/54,44/46,45/38,46/30,47/22,48/,
  49/14,50/6,51/61,52/53,53/45,54/37,55/29,56/,
  57/21,58/13,59/5,60/28,61/20,62/12,63/4,64/} {
  \pgfmathparse{int(add(1,divide(\x,8)))}
  \let\i\pgfmathresult
  \pgfmathparse{int(mod(\x,8))}
  \let\j\pgfmathresult
  \ifnum \j > 0
    \pgfmathparse{int(subtract(\i,1))}
    \let\k\pgfmathresult
    \pgfmathparse{int(subtract(\j,1))}
    \let\l\pgfmathresult

    \ifnum \j = 1
      \ifnum \i = 1
        \node [outnode,right=of in-\i\l] (in-\i\j) {\t};
      \else
        \node [outnode,below=of in-\k\j] (in-\i\j) {\t};
      \fi
    \else
      \node [outnode,right=of in-\i\l] (in-\i\j) {\t};
    \fi
  \fi
}
\stopscope

\startscope [on background layer]
  \node [dashed,draw=red!62.5!black,semithick,
    inner sep=1pt,fit=(in-11) (in-47)] (LH) {};
  \node [dashed,draw=red!62.5!black,semithick,
    inner sep=1pt,fit=(in-51) (in-87)] (RH) {};
  \node [labelnode,right=of LH] {$C_0$ (28比特)};
  \node [labelnode,right=of RH] {$D_0$ (28比特)};
\stopscope
\stoptikzpicture
}
\stopplacefigure

{\bf (2) PC-2置换}

如\in{图}[fig:des-pc2]所示，PC-2置换对两个半密钥块$C_i$和$D_i$分别处理，将每个半密钥块的28位
比特序列经挑选后重新排列成24位的比特序列，最后合并成48位子密钥$K_i$。

\startplacefigure[title={PC-2置换},reference=fig:des-pc2]
\midaligned{
\starttikzpicture
[pre/.style={<-,shorten <=1pt,>=stealth',semithick},
 post/.style={->,shorten >=1pt,>=stealth',semithick},
 labelnode/.style={inner sep=0,font=\switchtobodyfont[6pt]},
 cinnode/.style={shape=circle,draw=red!62.5!black,thick,fill=yellow!62.5!black,
 minimum size=5pt,font=\switchtobodyfont[6pt],inner sep=0},
 dinnode/.style={shape=circle,draw=red!62.5!black,thick,fill=yellow!62.5!black,
 minimum size=5pt,font=\switchtobodyfont[6pt],inner sep=0},
 dropnode/.style={shape=circle,draw=red!62.5!black,thick,fill=black,
 minimum size=5pt,font=\switchtobodyfont[6pt],inner sep=0},
 outnode/.style={shape=circle,draw=red!62.5!black,thick,fill=green!62.5!black,
 minimum size=5pt,font=\switchtobodyfont[6pt],inner sep=0},
 node distance=2pt]

\startscope
\node (Cin-0) {};
\foreach \i in {1,2,...,28} {
  \pgfmathparse{int(subtract(\i,1))}
  \let\j\pgfmathresult
  \node [cinnode, right=of Cin-\j] (Cin-\i) {};
}
\node [labelnode, above=of Cin-1] (Cinlabel-1) {1};
\node [labelnode, above=of Cin-28] (Cinlabel-28) {28};

\foreach \i in {9,18,22,25} {
  \node [dropnode] at (Cin-\i) {};
}

\node [below=2cm of Cin-2] (Cout-0) {};
\foreach \i in {1,2,...,24} {
  \pgfmathparse{int(subtract(\i,1))}
  \let\j\pgfmathresult
  \node [outnode, right=of Cout-\j] (Cout-\i) {};
}
\node [labelnode, below=of Cout-1] (Coutlabel-1) {1};
\node [labelnode, below=of Cout-24] (Coutlabel-24) {24};

\foreach \i/\j in {14/1,17/2,11/3,24/4,1/5,5/6,
  3/7,28/8,15/9,6/10,21/11,10/12,
  23/13,19/14,12/15,4/16,26/17,8/18,
  16/19,7/20,27/21,20/22,13/23,2/24} {
  \draw [post] (Cin-\i.south) -- (Cout-\j.north);
}
\stopscope

\startscope[on background layer]
\node [draw=yellow!62.5!black,very thick,inner xsep=5pt,inner ysep=5mm,
  rounded corners,
  fit=(Cinlabel-1) (Cin-28)] (C) {};
\node [below=3pt of C.north] {$C_i$};
\stopscope

\startscope
\node [right=2mm of Cin-28] (Din-0) {};
\foreach \i in {1,2,...,28} {
  \pgfmathparse{int(subtract(\i,1))}
  \let\j\pgfmathresult
  \node [dinnode, right=of Din-\j] (Din-\i) {};
  }
\node [labelnode, above=of Din-1] (Dinlabel-1) {1};
\node [labelnode, above=of Din-28] (Dinlabel-28) {28};

\foreach \i in {7,10,15,26} {
  \node [dropnode] at (Din-\i) {};
}

\node [below=2cm of Din-2] (Dout-0) {};
\foreach \i in {1,2,...,24} {
  \pgfmathparse{int(subtract(\i,1))}
  \let\j\pgfmathresult
  \node [outnode, right=of Dout-\j] (Dout-\i) {};
}
\node [labelnode, below=of Dout-1] (Doutlabel-1) {25};
\node [labelnode, below=of Dout-24] (Doutlabel-24) {48};

\foreach \i/\j in {41/1,52/2,31/3,37/4,47/5,55/6,
  30/7,40/8,51/9,45/10,33/11,48/12,
  44/13,49/14,39/15,56/16,34/17,53/18,
  46/19,42/20,50/21,36/22,29/23,32/24} {
  \pgfmathparse{int(subtract(\i,28))}
  \let\i\pgfmathresult
  \draw [post] (Din-\i.south) -- (Dout-\j.north);
}
\stopscope

\startscope[on background layer]
\node [draw=yellow!62.5!black,very thick,inner xsep=5pt,inner ysep=5mm,
  rounded corners,
  fit=(Dinlabel-1) (Din-28)] (D) {};
\node [below=3pt of D.north] {$D_i$};
\stopscope

\startscope[on background layer]
\node [draw=green!62.5!black,very thick,inner xsep=5pt,inner ysep=5mm,
  rounded corners,
  fit=(Cout-1) (Dout-24) (Coutlabel-1) (Doutlabel-24)] (Out) {};
\node [above=3pt of Out.south] {$K_i$};
\stopscope

\stoptikzpicture
}
\stopplacefigure

\stopsubsection

\stopsection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startsection[title={分组密码：3DES},reference=sec:3des]
\index{sec:3des}




\stopsection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startsection[title={分组密码：AES},reference=sec:aes]
\index{sec:aes}


\stopsection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startsection[title={分组密码：Blowfish},reference=sec:blowfish]
\index{sec:blowfish}


\stopsection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startsection[title={本章小结}]

\stopsection

\stopchapter

\stopcomponent
