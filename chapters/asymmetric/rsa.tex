\startcomponent rsa

\startsection[title={RSA加密算法},reference=sec:rsa]
\index{sec:rsa}

本节我们要介绍的是RSA非对称加密算法。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和
伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人
姓氏开头字母拼在一起组成的。

\startsubsection[title={RSA必备数学知识},reference=subsec:rsa-math]

在讲解RSA加密算法之前，有必要了解一下一些RSA所必备的数论知识。数论是纯粹数学的分支之一，主要研究整数的性质，
我们先来了解如下几个基本的概念。

\startitemize
% https://blog.csdn.net/q376420785/article/details/8557266
\head {\bf 质数}

质数是指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。这个概念，我们在上小学的时候都
学过了，这里就不再过多解释了。

\head {\bf 互质数}

公约数只有1的两个数叫做互质数。很显然，两个不同的质数一定是互质数。常用的判断两个数是否互质的算法是辗转相除法，
又称欧几里得算法（Euclidean algorithm）。辗转相除法首次出现于欧几里得的《几何原本》，而在中国则可以追溯至
东汉出现的《九章算术》。辗转相除法用于计算两个整数的最大公约数。如果两个整数的最大公约数为1，则说明它们必为互质数。

辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和较大数相除余数的最大公约数。例如，252和105的最大
公约数是21（$252 = 21 \times 12; 105 = 21 \times 5$）；因为$252 − 105 = 21 \times (12 − 5) = 147$，
所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至
其中一个变成0。这时，所剩下的还没有变成0的数就是两数的最大公约数。辗转相除法是一种递归算法，每一步计算的输出值
就是下一步计算时的输入值。

假设，我们要计算$a$和$b$（$a >= b$）两个数的最大公约数$\gcd(a,b)$，第$i$步带余除法的商为$q_i$，
余数为$r_{i+1}$，则辗转相除法可以写成如下形式：

\startformula
\startmathalignment[n=4,align=middle]
\NC r_0 \NC   =    \NC a \NR
\NC r_1 \NC   =    \NC b \NR
\NC     \NC \vdots \NC   \NR
\NC r_{i+1} \NC =  \NC r_{i-1} - q_i r_i \quad (0 \leq r_{i+1} < \lvert r_i \rvert ) \NR
\NC     \NC \vdots \NC   \NR
\stopmathalignment
\stopformula

当某步得到的$r_{i+1}=0$时，计算结束。上一步得到的$r_i$即为$a$、$b$的最大公约数。 

\head {\bf 模运算}

模运算即求余运算。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余数，则二整数
同余。两个整数$a$、$b$，若它们除以正整数$m$所得的余数相等，则称$a$和$b$对于模$m$同余，记作: $a \equiv b \pmod{m}$；
读作：$a$同余于$b$模$m$，或者$a$与$b$关于模$m$同余。例如：$26 \equiv 14 \pmod{12}$。

% https://zh.wikipedia.org/zh-cn/%E5%90%8C%E9%A4%98#%E6%80%A7%E8%B4%A8
模运算具有如下一些基本性质：

    \startitemize[3]
    \head {\bf 整除性}
    \startformula
    a \equiv b \pmod{m} \Rightarrow k \cdot m = a - b, k \in \mathbb{Z}.
    \stopformula
    $k$为整数集$\mathbb{Z}$中的某个整数。也就是说，$a$和$b$之差是$m$的倍数。

    \head {\bf 传递性}
    \startformula
    \left.\startmatrix
    a \equiv b \pmod{m} \cr
    b \equiv c \pmod{m} \cr
    \stopmatrix\right\}
    \Rightarrow
    a \equiv c \pmod{m}.
    \stopformula

    \head {\bf 保持基本运算}

    \startformula
    \left.\startmatrix
    a \equiv b \pmod{m} \cr
    c \equiv d \pmod{m} \cr
    \stopmatrix\right\}
    \Rightarrow
    \left\{\startmatrix
    a \pm c \equiv b \pm d \pmod{m} \cr
    ac \equiv bd \pmod{m} \cr
    \stopmatrix\right.
    \stopformula

    这个性质可以进一步引申出：

    \placeformula[formula:mod-exp]
    \startformula
    a \equiv b \pmod{m} \Rightarrow
    \left\{\startmatrix
    an \equiv bn \pmod{m}, \forall n \in \mathbb{Z} \cr
    a^n \equiv b^n \pmod{m}, \forall n \in \mathbb{N}^0 \cr
    \stopmatrix\right.
    \stopformula

    \head {\bf 除法原理}

    如果$m_1$和$m_2$都可以整除$(a-b)$，那么$m_1$和$m_2$的最小公倍数${\mathrm lcm}(m_1,m_2)$必定可以整除$(a-b)$，
    记为$a \equiv b \pmod{{\mathrm lcm}(m_1,m_2)}$。这可以推广成以下性质：

    \placeformula[formula:mod-m]
    \startformula
    \left.\startmatrix
    a \equiv b \pmod{m_1} \cr
    a \equiv b \pmod{m_2} \cr
    \vdots  \cr
    a \equiv b \pmod{m_n} \cr
    \stopmatrix\right\}
    \Rightarrow
    a \equiv b \pmod{{\mathrm lcm}(m_1,m_2,\cdots,m_n)}, \quad (n \geq 2).
    \stopformula

    \stopitemize

\head {\bf 模反元素}

两个正整数$a$和$m$互质，那么一定可以找到整数$b$，使得 $ab-1$被$m$整除，即$ab\equiv 1 \pmod{m}$，这时，$b$就
叫做$a$的模反元素，也称为模倒数或者模逆元。

\head {\bf 扩展欧几里得算法求模反元素}

求模反元素是RSA加密算法中获得所需公钥、私钥的必要步骤。扩展欧几里得算法是欧几里得算法（辗转相除法）的扩展，可以在求得$a$、
$b$的最大公约数的同时，能找到整数$x$、$y$（其中一个很可能是负数），使它们满足如下的贝祖等式：

\startformula
ax + by = \gcd(a,b)
\stopformula

扩展欧几里得算法在辗转相除法的基础上每步增加了$s_i$和$t_i$两组序列，并令$s_0 = 1, s_1 = 0$和$t_0 = 0, t_1 = 1$，
在辗转相除法每步计算$r_{i+1}$之外额外计算 $s_{i+1} = s_{i−1} − q_i s_i$和$t_{i+1} = t_{i−1} − q_i t_i$，亦即：

\placeformula[formula:extend-euclidean]
\startformula
\startmathalignment[n=7,align={right,left,right,left,right,left,middle}]
\NC r_0 \NC = a, \NC \quad s_0 \NC = 1, \NC \quad t_0 \NC = 0; \NC \NR
\NC r_1 \NC = b, \NC \quad s_1 \NC = 0, \NC \quad t_1 \NC = 1; \NC \NR
\NC   \NC \vdots \NC   \NC \vdots \NC   \NC \vdots \NC \NR
\NC r_{i+1} \NC = r_{i-1} - q_i r_i, \NC \quad s_{i+1} \NC = s_{i-1} - q_i s_i, \NC \quad t_{i+1} \NC = t_{i-1} - q_i t_i; \NC \quad (0 \leq r_{i+1} < \lvert r_i \rvert ) \NR
\NC   \NC \vdots \NC   \NC \vdots \NC   \NC \vdots \NC \NR
\stopmathalignment
\stopformula

算法结束条件与辗转相除法一致，也是$r_{i+1}=0$，此时所得的$s_i$和$t_i$即满足等式$\gcd(a,b)=r_{i}=a s_i + b t_i$。

下表以$a = 240$、$b = 46$为例演示了扩展欧几里得算法。所得的最大公约数是2，所得贝祖等式为
$\gcd(240,46)=2=-9 \times 240+47 \times 46$。

\midaligned{
\starttable[|c|c|c|c|c|]
\HL
\NC {\bf 序号$i$}  \VL {\bf 商$q_{i-1}$} \NC {\bf 余数$r_i$} \NC {\bf $s_i$} \NC {\bf $t_i$} \NC\SR
\HL
\NC 0  \VL                 \NC 240                  \NC 1                    \NC 0                      \NC\FR
\NC 1  \VL                 \NC 46                   \NC 0                    \NC 1                      \NC\MR
\NC 2  \VL $240 \div 46=5$ \NC $240−5 \times 46=10$ \NC $1−5 \times 0=1$     \NC $0−5 \times 1=−5$      \NC\MR
\NC 3  \VL $46 \div 10=4$  \NC $46−4 \times 10=6$   \NC $0−4 \times 1=−4$    \NC $1−4 \times (−5)=21$   \NC\MR
\NC 4  \VL $10 \div 6=1$   \NC $10−1 \times 6=4$    \NC $1−1 \times (−4)=5$  \NC $−5−1 \times 21=−26$   \NC\MR
\NC 5  \VL $6 \div 4=1$    \NC $6−1 \times 4=2$     \NC $−4−1 \times 5=−9$   \NC $21−1 \times (−26)=47$ \NC\MR
\NC 6  \VL $4 \div 2=2$    \NC $4−2 \times 2=0$     \NC $5−2 \times (−9)=23$ \NC $−26−2 \times 47=−120$ \NC\LR
\HL
\stoptable
}

\head {\bf 欧拉函数}

在数论中，对正整数$n$，欧拉函数$\varphi(n)$是小于或等于$n$的正整数中与$n$互质的数的数目。此函数以其首名研究者欧拉
命名，它又称为$\varphi$函数或是欧拉总计函数（totient function）。例如$\varphi(8) = 4$，因为1、3、5、7均和8互质。

当$n$为质数时，$\varphi(n) = n-1$。 欧拉函数是积性函数，即当$m$和$n$互质时，$\varphi(mn)=\varphi(m)\varphi(n)$。

\head {\bf 欧拉定理}

欧拉定理证明当$a$、$n$为两个互质的正整数时，则有

\placeformula[formula:eula-theorem]
\startformula
a^{\varphi(n)} \equiv 1 \pmod{n}
\stopformula

其中$\varphi(n)$为欧拉函数。
欧拉定理的证明过程非常复杂，这里，我们只要记住这个结论就可以了。

上述结果可分解为$a^{\varphi(n)}=a \cdot a^{\varphi(n)-1} \equiv 1 \pmod{n}$，其中$a^{\varphi(n)-1}$即为$a$关于
模$n$之模反元素。

当$n$为质数$p$时，结合欧拉函数，就有：$a^{p-1} \equiv 1 {\pmod p}$，这就是著名的费马小定理，是欧拉定理的特例。

\stopitemize

\stopsubsection

\startsubsection[title={RSA公钥和私钥的生成},reference=subsec:rsa-keys]

假设消息的接收方需要通过一个不可靠的通道接收某个发送方的消息，接收方可以用以下的方式来产生一个公钥和一个私钥：

\startitemize[n]
\item 任意选择两个特别大的质数$p$和$q$ ($p \neq q$)，计算$N=pq$；

\item 根据欧拉函数，求得$r=\varphi(N)=\varphi(p)\varphi(q)=(p-1)(q-1)$；

\item 选择一个小于$r$的整数$e$，使$e$与$r$互质。并求得$e$关于$r$的模逆元，命名为$d$，那么，$ed\equiv 1\pmod{r}$。

\item 将$p$和$q$的记录销毁。
\stopitemize

$(N,e)$是公钥，$(N,d)$是私钥。消息接收方将他的公钥$(N,e)$传给发送方，而将他的私钥$(N,d)$秘密保存起来。 

\stopsubsection

\startsubsection[title={RSA加密和解密},reference=subsec:rsa-enc]

{\bf 加密消息}

假设发送方要给接收方发送一个消息$M$，他知道接收方产生的$N$和$e$。他使用事先和接收方约好的格式将消息$M$转换为
一个小于$N$的非负整数$m$，比如，他可以将每一个字转换为这个字的Unicode码，然后将这些Unicode码连接在一起组成
Unicode码串。假如他的信息非常长超过了$N$的位数，他可以将这个信息分为多个段，然后将每一段转换为$m$。用下面这个
公式他可以将每一段$m$加密为$c$：

\startformula
c \equiv m^{e} \pmod{N}
\stopformula

计算$c$并不复杂。发送方算出$c$后就可以将它传递给接收方。 

{\bf 解密消息}

接收方收到发送方的消息$c$之后，就可以利用他的私钥$d$来解码。他可以用下面这个公式将$c$解密还原回$m$：

\startformula
m \equiv c^{d} \pmod{N}
\stopformula

接收方利用上面的公式对来自发送方的每一段$c$解密得到所有的$m$后，便可以复原消息$M$。

{\bf 正确性证明}

我们只要证明$m^{ed} \equiv m \pmod{N}$对所有的$m~(m<N)$都成立，便能证明解密公式的正确性。

首先，将模运算的基本性质（\in{公式}[formula:mod-exp]）应用在加密公式上，可知

\startformula
c^d \equiv m^{e \cdot d} \pmod{N}
\stopformula

已知$ed \equiv 1 \pmod{r}$，即 $ed = 1 + h\varphi(N), h \in \mathbb{Z}$。那么有

\startformula
m^{ed} = m^{1 + h\varphi(N)} = m \cdot m^{h\varphi(N)} = m\left(m^{\varphi(N)}\right)^{h}
\stopformula

下面，我们分别从$m$与$N$互质和不互质两种情况来证明$m^{ed} \equiv m \pmod{N}$。

\startitemize[n,packed]
\item 若$m$与$N$互质，则由欧拉定理（\in{公式}[formula:eula-theorem]）可得：

\startformula
m^{ed} \equiv  m\left(m^{\varphi(N)}\right)^{h} \equiv m(1)^{h} \equiv m \pmod{N}
\stopformula

\item 若$m$与$N$不互质，那么$m$必定为质数$p$或者$q$的倍数。不失一般性考虑$m=ph$，以及$ed−1=k(q−1)$，得：

\startformula
m^{ed} = (ph)^{ed} \equiv 0 \equiv ph \equiv m \pmod{p}
\stopformula

\startformula
m^{ed} = m^{ed-1} m = m^{k(q-1)} m = (m^{q-1})^k m \equiv 1^{k} m \equiv m \pmod{q}
\stopformula

因为$N=pq$，根据模运算性质\in{公式}[formula:mod-m]，可得$m^{ed} \equiv m \pmod{N}$。
\stopitemize

因此，不论$m$与$N$是否互质，都有$m^{ed} \equiv m \pmod{N}$，解密公式的正确性得证。

{\bf 示例}

我们用如下的例子再来解释RSA加密和解密。为简化计算和说明，我们特意用了较小的的质数。

\startitemize[n]
\item 选择两个不同的质数，$p=61$、$q=53$，计算得到$N=61 \times 53 = 3233$。

\item 根据欧拉函数，计算$r=\varphi(N)=\varphi(p)\varphi(q)=(p-1)(q-1)=3120$。

\item 随机选择一个整数$e$，使其满足条件$1 < e < \varphi(N)$，并且$e$与$\varphi(N)$互质。为了简化计算，在1到3120之间，我们选择$e=19$。

\item 计算$e$关于$\varphi(N)$的模反元素$d$。根据模反元素的定义，可知$ed \equiv 1 \pmod{\varphi(N)} \Rightarrow ed - 1 = k\varphi(N)$，于是，找$e$关于$\varphi(N)$的模反元素$d$，实质上就是对下面的这个二元一次方程求解：

\startformula
e x + \varphi(N) y = 1
\stopformula

已知，$e=19$、$\varphi(N) = 3120$，那么，该二元一次方程可以确定为：

\startformula
19 x + 3120 y = 1
\stopformula

根据扩展欧几里得算法（\in{公式}[formula:extend-euclidean]），令$a=\varphi(N)=3120$、$b=e=19$，如下表格展示了
扩展欧几里得算法求解的过程。

\midaligned{
\starttable[|c|c|c|c|c|]
\HL
\NC {\bf 序号$i$}  \VL {\bf 商$q_{i-1}$} \NC {\bf 余数$r_i$} \NC {\bf $s_i$} \NC {\bf $t_i$} \NC\SR
\HL
\NC 0  \VL                    \NC 3120                 \NC 1                  \NC 0                      \NC\FR
\NC 1  \VL                    \NC 19                   \NC 0                  \NC 1                      \NC\MR
\NC 2  \VL $3120 \div 19=164$ \NC $3120−164 \times 19=4$ \NC $1−164 \times 0=1$   \NC $0−164 \times 1=−164$      \NC\MR
\NC 3  \VL $19 \div 4=4$  \NC $19−4 \times 4=3$   \NC $0−4 \times 1=−4$  \NC $1−4 \times −164=657$     \NC\MR
\NC 4  \VL $4 \div 3=1$   \NC $4−1 \times 3=1$    \NC $1−1 \times −4=5$  \NC $−164−1 \times 657=-821$   \NC\MR
\NC 5  \VL $3 \div 1=3$    \NC $3−3 \times 1=0$     \NC $−4−3 \times 5=−19$ \NC $657−3 \times -821=3120$   \NC\MR
\HL
\stoptable
}

最终，求得

\startformula
3120 \times 5 + 19 \times (-821) = 1
\stopformula

据此，我们得出-821是19关于3120的模反元素。由于，我们期望得到一个正的模反元素，我们可以对上式稍作变化：

\startformula
3120 \times 5 + 19 \times (-821) = 3210 \times 5 - 3120 \times 19 + 19 \times (-821) + 3120 \times 19 = 
3120 \times (-14) + 19 \times 2299 = 1
\stopformula

所以，计算得到19关于3120的模反元素为2299，即$d=2299$。

\item 将$N$和$e$封装成公钥，$N$和$d$封装成私钥。在该例中，$N=3233$、$e=19$、$d=2299$，所以，
公钥就是$(3233,19)$，私钥就是$(3233,2299)$。
\stopitemize

现在，用大写字母\type{A}（ASCII编码值为65）来验算。对\type{A}加密后的数值为：

\startformula
c = 65^{19} \pmod{3233} = 27883916671284601415195465087890625 \pmod{3233} = 232
\stopformula

加密后的$c$经过解密公式计算后，可以还原回\type{A}对应的ASCII编码值。

\startformula
m = 232^{2299} \pmod{3233} = 65
\stopformula

因为Python支持大数计算，我们使用Python解释器对解密公式的计算进行了验证，如下：

{
\switchtobodyfont[7pt]
\starttyping
>>> pow(232, 2299)
180666347328265653258383894933004371487240092743537919407108211261805084212220403841284148846624524015919076278935762369
566193343373349827864820080189518110480760747411699792950837852232292376913816411843615809211304474825053467587778518242
705796906398756110666492666972719706854587962788746728592081235628180351761034041597084051469628142945625665210401870986
442721134645212335726733133216636984545423758259808743479587355455526033817862572011080602555736097287480848752219066210
619113008297797669429153077700180340012046587925451990211178787025745543474937384533184941240981443646810905632560017797
164576088730314607384211004327617327635178100260842037549674043154025693004064517193174075606873030274879212886640256718
665968747046854756558556199498208619743014219982493267989161266257659462813102634476691108885295057325167573493051735583
673050390800019703579110868646618431152738053248378892584841525864881331330558804557033686702663256220319720619864147462
457892300319645383317856427729293119136561330755943202534086697378417807270552100178840044134499523362403674966693591336
577177957298225146756165001934902583109171687460847444019203743457164082131742194034466322608427604603401435949150255353
167890669197496031009024840083448661115491646464303377615784066236199296533834394865384197075062745634267534418168640817
424468556772942925280897253355617717434342285080762099998828522129417566010479204644104292099767595547713995184596564770
846187113210570630262758496094801761926960834360049939434211153760029990028088059951335925931689078224504960623918651079
688626485351471887329228750521678743769719298330078395342693680820677607978860075472603284591081978845348401933010582961
715134552244237772732343129376084801065135826082799548514816580275002572759105226991583897249209302400084882484902231414
679276530977345493022958064891113046805422308317132979749963467378921937799748997220709775693863201849843276213035220170
545609986454363496887389240032422832383402171501297486825889565827479630876068855000462949483622905863457096209612769289
374979551812079424992612524776964098670315062860833982712896496580209652265818710052177749601018268634694056192881801971
412595297556191324528937998152904330753015249551827717505770160953381451044451543347782430157121255731279700992538585215
932515665528805150133600611761358997307194927012520356077213596602633684699034284488910849840539184412861752193259315452
246176738190057730572995438895207000236623099243884076505984398862702283169615494664457971770570987245194733806323377122
286109671358484163490956375346459888738581962269779143849006354996175630784722798139982235293336772432981439666083041949
844566275218153109084134275113846364694249405528268547453378279436208678184219574972752175517012613535399534905666380302
020953429975260331393956656812841803685754758104089627323030398750974242964516555654616911555326975921943131513025556246
120840048465833578351161205816617445169310771103115190663603250718384153612087369210173158164674952629055714154911725030
425814161105559997027124793318828459960085593871242398252958038699416980182447786555363244184674123757645842637024065381
596935308564528073626647114113643070580514753787312750381977711286475543663087935357863164168758014129308963875253198862
654595257149816784182103395744978482681259217580815579619074400671791525472006042878557602774594655191057318536471996771
844829549301435988658254276688766710499692948849990750468123389030212069061502187495557598988921313106042297783167081041
187756858587622362659710874999186306351606161881751791533071144356243503072548236578126339032301833932214768243450446076
546215503531642936182239633636385811688670571778861864160991173020990886148880382426313463334638563928251329292293440632
566524085488682556020848138573214990137866674087324317521837880861474015052622836241792933113303883752085594517898768295
821375387986639834878495672170462777967186971519909015894898616734179333521581001342356401303003610109565476104109591222
517044401265721639725369721984091454411669690674506527715443041918517320236802640545564447298478565733204333722951402934
602220878907076431174092629244853045388609058583374019347120706157193268810219917567810835286250340074435861653660982469
633473651169328479699632556730006394457047838662896045675565354054866829326251395536821826889945701382282055743315085377
558076704519355427234037456315229107129234520458141890558027526137706513643583784798607060872176775829019661560018081487
961909663707872025542811874710646966968336608251065322703223428064237047055508341249916565471793771656314815573207685823
368749182280730888919083522561541442756713823316443382258971741072627198193854577691742068876264446763965940106466936027
020366123173011942389948399002949797996104367980534999386508969071033488551861821644023744260577425996826859987231024113
767835439286860962584280821382521198271684888688163305338394177651569643021607505665913530800289662003939322128227107953
913460648991579219516942778577488855889952914922420300636158048865264323480272073464067440235372581890145511615641221513
616092969911983441384427415821010492563014085693561040698558019006431856499211494470260645913068840992705561721182382665
255004593624625699359469285979121572481215011787152301618492896251213797373595407083525551981643590692024635498114713236
366557323067311457655290559131727494540203647963662930161610554325430764210413722454942260442855947985932505535235434067
774719812532475107993524856251238842368
>>> pow(232, 2299) % 3233
65
\stoptyping
}

\stopsubsection

\startsubsection[title={RSA算法的安全性},reference=subsec:rsa-security]

回顾RSA密钥生成的过程，一共出现了6个数字：质数$p$和$q$、$N$、$\varphi(N)$、$e$以及$d$。这6个数字中，$N$和$e$组成了公钥，是对外公开的。
其余4个数字都不公开，最关键的是$d$，因为它是私钥的一部分。那么，有没有可能在知道$N$和$e$的情况下推导出$d$呢？

已知$ed \equiv 1 \pmod{\varphi(N)}$，再加上$N$和$e$是公开的，如果能够计算出$\varphi(N)$，那么就能根据扩展欧几里得算法计算出$d$。
而$\varphi(N)=(p-1)(q-1)$，只有知道$p$和$q$，才能计算出$\varphi(N)$。同时，我们也知道$N=pq$，因此，在已知$N$和$e$来推导$d$的最终
目标就落在对$N$进行质因数分解了。所以，我们可以得到这样的结论：{\it 如果$N$可以被质因数分解，我们就可以根据公钥推导出私钥}。

你也许觉得解决这个问题挺简单的，平时都写过对整数做因数分解的小程序。可是，对于大整数的因数分解，迄今为止还是一件非常困难的事情。目前，除了
暴力破解之外，还没有发现别的有效方法。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈
可靠。如果哪一天有人找到一种快速因数分解的算法，那么RSA的安全性就崩塌了。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能
被暴力破解。到目前为止，还没有任何可靠的攻击RSA算法的方式。

举例来说，你可以轻而易举地对3233进行因数分解（$3233 = 61 \times 53$），但是对下面这个整数进行因数分解就已经特别困难了。


\startformula
\startmatrix[align=left]
\NC 12301866845301177551304949 \NR
\NC 58384962720772853569595334 \NR
\NC 79219732245215172640050726 \NR
\NC 36575187452021997864693899 \NR
\NC 56474942774063845925192557 \NR
\NC 32630345373154826850791702 \NR
\NC 61221429134616704292143116 \NR
\NC 02221240479274737794080665 \NR
\NC 351419597459856902143413   \NR
\stopmatrix
\quad = \quad 
\startmatrix[align=left]
\NC 33478071698956898786044169 \NR
\NC 84821269081770479498371376 \NR
\NC 85689124313889828837938780 \NR
\NC 02287614711652531743087737 \NR
\NC 814467999489               \NR
\stopmatrix
\quad \times \quad
\startmatrix[align=left]
\NC 36746043666799590428244633 \NR
\NC 79962795263227915816434308 \NR
\NC 76426760322838157396665112 \NR
\NC 79233373417143396810270092 \NR
\NC 798736308917               \NR
\stopmatrix
\stopformula

事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，
因此目前被破解的最长RSA密钥就是768位。NIST建议的RSA密钥长度为至少2048位。

\stopsubsection

\stopsection

\stopcomponent